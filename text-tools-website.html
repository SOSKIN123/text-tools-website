<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Инструменты для работы с текстом</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            background-color: #f0f0f0;
        }
        #sidebar {
            width: 250px;
            background-color: #333;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }
        #content {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-radius: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        textarea, input[type="text"], select {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 10px;
            font-size: 16px;
        }
        textarea {
            height: 300px;
            resize: vertical;
        }
        #result {
            height: 300px;
            margin-top: 10px;
        }
        .mode-button-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .mode-button {
            flex-grow: 1;
            text-align: left;
            padding: 10px;
            background-color: #444;
            color: white;
            border: none;
            transition: background-color 0.3s;
            border-radius: 10px;
            cursor: pointer;
        }
        .mode-button:hover {
            background-color: #555;
        }
        .active {
            background-color: #4CAF50;
        }
        .drag-handle {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            cursor: move;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='white'%3E%3Cpath d='M7 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 2zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 14zm6-8a2 2 0 1 0-.001-4.001A2 2 0 0 0 13 6zm0 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 14z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
        }
        .dragging {
            opacity: 0.5;
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
        }
        
        .copy-button svg {
            width: 20px;
            height: 20px;
            fill: #4CAF50;
        }
        
        #result-container {
            position: relative;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .burger-menu {
            display: none;
            cursor: pointer;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
        }

        .burger-menu div {
            width: 35px;
            height: 5px;
            background-color: #333;
            margin: 6px 0;
            transition: 0.4s;
        }

        .close-button {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            cursor: pointer;
            color: #fff;
            background-color: #4CAF50;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
            border-radius: 50%;
        }

        .close-button:hover {
            background-color: #45a049;
        }

        @media (max-width: 768px) {
            body {
                position: relative;
                overflow-x: hidden;
            }
            #sidebar {
                position: fixed;
                left: -100%;
                top: 0;
                height: 100%;
                width: 80%;
                max-width: 250px;
                transition: 0.3s;
                z-index: 1001;
                padding-top: 50px;
                background-color: #333;
            }
            #sidebar.open {
                left: 0;
            }
            .burger-menu {
                display: block;
                position: fixed;
                top: 10px;
                left: 10px;
                z-index: 1002;
            }
            #content {
                margin-left: 0;
                width: 100%;
                transition: 0.3s;
            }
            body.sidebar-open #content {
                filter: blur(3px);
                pointer-events: none;
            }
            h1 {
                font-size: 24px;
            }
            textarea, input[type="text"], select {
                font-size: 14px;
            }
            button {
                font-size: 14px;
                padding: 8px 16px;
            }
            .mode-button-container {
                margin-bottom: 5px;
            }
            .mode-button {
                padding: 8px;
                font-size: 14px;
            }
            .drag-handle {
                display: block;
                touch-action: none;
            }
            #result {
                height: 200px;
            }
            .close-button {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="burger-menu" id="burger-menu">
        <div></div>
        <div></div>
        <div></div>
    </div>
    <div id="sidebar">
        <span class="close-button" id="close-button">&times;</span>
        <h2>Режимы</h2>
        <div id="mode-buttons"></div>
    </div>
    <div id="content">
        <h1 id="current-mode-title">Инструменты для работы с текстом</h1>
        <textarea id="input" placeholder="Введите текст здесь..."></textarea>
        <div id="options"></div>
        <button id="process-button">Обработать</button>
        <div id="result-container">
            <textarea id="result" readonly></textarea>
            <button class="copy-button" id="copy-button" title="Копировать результат">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                </svg>
            </button>
        </div>
    </div>

    <div id="notification" class="notification">Результат скопирован в буфер обмена!</div>

    <script>
        let currentMode = '';
        let draggedItem = null;
        const modes = [
            {id: 'removeDuplicates', name: 'Удалить дубликаты строк'},
            {id: 'shuffleLines', name: 'Перемешать строки'},
            {id: 'changeCase', name: 'Изменить регистр'},
            {id: 'addPrefix', name: 'Добавить префикс'},
            {id: 'addSuffix', name: 'Добавить суффикс'},
            {id: 'textStatistics', name: 'Статистика текста'},
            {id: 'findAndReplace', name: 'Найти и заменить'},
            {id: 'numberLines', name: 'Пронумеровать строки'},
            {id: 'extractLinks', name: 'Извлечь ссылки'},
            {id: 'sortLines', name: 'Сортировать'},
            {id: 'removeEmptyLines', name: 'Удалить пустые строки'},
            {id: 'removeCharacters', name: 'Удалить символы из списка'},
            {id: 'removeTextAroundSymbol', name: 'Удалить текст до/после символа'}
        ];

        console.log('Modes:', modes);

        function createModeButtons() {
            console.log('Creating mode buttons');
            const modeButtons = document.getElementById('mode-buttons');
            if (!modeButtons) {
                console.error('Element with id "mode-buttons" not found');
                return;
            }
            modeButtons.innerHTML = '';
            
            let order = JSON.parse(localStorage.getItem('buttonOrder')) || modes.map(mode => mode.id);
            console.log('Initial order from localStorage:', order);
            
            // Проверяем, есть ли в order все режимы из modes
            const missingModes = modes.filter(mode => !order.includes(mode.id));
            if (missingModes.length > 0) {
                console.log('Adding missing modes to order:', missingModes);
                order = [...order, ...missingModes.map(mode => mode.id)];
                localStorage.setItem('buttonOrder', JSON.stringify(order));
            }
            
            console.log('Updated button order:', order);
            
            order.forEach((modeId, index) => {
                const mode = modes.find(m => m.id === modeId);
                console.log('Creating button for mode:', mode);
                if (mode) {
                    const container = document.createElement('div');
                    container.className = 'mode-button-container';
                    container.draggable = true;
                    container.dataset.modeId = mode.id;

                    const dragHandle = document.createElement('div');
                    dragHandle.className = 'drag-handle';

                    const button = document.createElement('button');
                    button.className = 'mode-button';
                    button.textContent = mode.name;
                    button.dataset.modeId = mode.id;
                    button.addEventListener('click', function() {
                        setMode(this.dataset.modeId);
                    });

                    container.appendChild(dragHandle);
                    container.appendChild(button);
                    modeButtons.appendChild(container);

                    // Устанавливаем первую кнопку в списке как активную по умолчанию
                    if (index === 0) {
                        setMode(mode.id);
                    }
                } else {
                    console.warn('Mode not found for id:', modeId);
                }
            });

            addDragListeners();
            addTouchDragListeners(); // Добавляем поддержку перетаскивания на сенсорных устройствах

            if (window.innerWidth <= 768) {
                document.querySelectorAll('.drag-handle').forEach(handle => {
                    handle.style.display = 'none';
                });
            }
            console.log('Mode buttons created');
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-button').forEach(btn => btn.classList.remove('active'));
            const activeButton = document.querySelector(`.mode-button[data-mode-id="${mode}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
                // Обновляем заголовок с названием текущего режима
                const currentModeTitle = document.getElementById('current-mode-title');
                currentModeTitle.textContent = activeButton.textContent;
            }
            updateOptions();

            // Закрываем меню на мобильных устройствах после выбора режима
            if (window.innerWidth <= 768) {
                toggleSidebar();
            }
        }

        function updateOptions() {
            const optionsDiv = document.getElementById('options');
            optionsDiv.innerHTML = '';

            switch (currentMode) {
                case 'changeCase':
                    optionsDiv.innerHTML = `
                        <select id="caseOption">
                            <option value="upper">Верхний регистр</option>
                            <option value="lower">Нижний регистр</option>
                        </select>
                    `;
                    break;
                case 'addPrefix':
                case 'addSuffix':
                    optionsDiv.innerHTML = `
                        <input type="text" id="affix" placeholder="${currentMode === 'addPrefix' ? 'Префикс' : 'Суффикс'}">
                    `;
                    break;
                case 'findAndReplace':
                    optionsDiv.innerHTML = `
                        <input type="text" id="findText" placeholder="Найти">
                        <input type="text" id="replaceText" placeholder="Заменить на">
                    `;
                    break;
                case 'numberLines':
                    optionsDiv.innerHTML = `
                        <select id="numberFormat">
                            <option value="bracket">1) </option>
                            <option value="dot">1. </option>
                            <option value="space">1 </option>
                        </select>
                    `;
                    break;
                case 'sortLines':
                    optionsDiv.innerHTML = `
                        <select id="sortOption">
                            <option value="asc">По возрастанию</option>
                            <option value="desc">По убыванию</option>
                        </select>
                    `;
                    break;
                case 'removeCharacters':
                    optionsDiv.innerHTML = `
                        <input type="text" id="charactersToRemove" placeholder="Символы для удаления" value="@#%^:&*()?!<>/'{}[]~«»">
                    `;
                    break;
                case 'removeTextAroundSymbol':
                    optionsDiv.innerHTML = `
                        <input type="text" id="symbolToRemoveAround" placeholder="Символ" maxlength="1">
                        <select id="removeDirection">
                            <option value="before">Удалить до символа</option>
                            <option value="after">Удалить после символа</option>
                        </select>
                    `;
                    break;
            }
        }

        function processText() {
            const input = document.getElementById('input');
            if (!input) return;
            const inputValue = input.value;
            let result = '';

            // Всегда удаляем дубликаты строк
            const uniqueLines = [...new Set(inputValue.split('\n'))];

            switch (currentMode) {
                case 'removeDuplicates':
                    result = uniqueLines.join('\n');
                    break;
                case 'shuffleLines':
                    result = uniqueLines.sort(() => Math.random() - 0.5).join('\n');
                    break;
                case 'changeCase':
                    const caseOption = document.getElementById('caseOption').value;
                    result = caseOption === 'upper' ? uniqueLines.join('\n').toUpperCase() : uniqueLines.join('\n').toLowerCase();
                    break;
                case 'addPrefix':
                    const prefix = document.getElementById('affix').value;
                    result = uniqueLines.map(line => prefix + line).join('\n');
                    break;
                case 'addSuffix':
                    const suffix = document.getElementById('affix').value;
                    result = uniqueLines.map(line => line + suffix).join('\n');
                    break;
                case 'textStatistics':
                    const lines = uniqueLines;
                    const words = uniqueLines.join('\n').match(/\S+/g) || [];
                    const chars = uniqueLines.join('\n').length;
                    result = `Строк: ${lines.length}\nСлов: ${words.length}\nСимволов: ${chars}`;
                    break;
                case 'findAndReplace':
                    const findText = document.getElementById('findText').value;
                    const replaceText = document.getElementById('replaceText').value;
                    result = uniqueLines.join('\n').replace(new RegExp(findText, 'g'), replaceText);
                    break;
                case 'numberLines':
                    const format = document.getElementById('numberFormat').value;
                    let formatStr;
                    switch (format) {
                        case 'bracket':
                            formatStr = ') ';
                            break;
                        case 'dot':
                            formatStr = '. ';
                            break;
                        case 'space':
                            formatStr = ' ';
                            break;
                    }
                    result = uniqueLines.map((line, index) => `${index + 1}${formatStr}${line}`).join('\n');
                    break;
                case 'extractLinks':
                    const urlRegex = /(https?:\/\/[^\s]+)|(www\.[^\s]+)|([a-zA-Z0-9._-]+\.[a-zA-Z]{2,6}(?:\/[^\s]*)?)/g;
                    result = (uniqueLines.join('\n').match(urlRegex) || []).join('\n');
                    break;
                case 'sortLines':
                    const sortOption = document.getElementById('sortOption').value;
                    result = uniqueLines.sort((a, b) => sortOption === 'asc' ? a.localeCompare(b) : b.localeCompare(a)).join('\n');
                    break;
                case 'removeEmptyLines':
                    result = uniqueLines.filter(line => line.trim() !== '').join('\n');
                    break;
                case 'removeCharacters':
                    const charactersToRemove = document.getElementById('charactersToRemove').value;
                    const regex = new RegExp(`[${charactersToRemove.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}]`, 'g');
                    result = uniqueLines
                        .map(line => line.replace(regex, ''))
                        .filter(line => line.trim() !== '') // Удаляем пустые строки
                        .join('\n');
                    break;
                case 'removeTextAroundSymbol':
                    const symbol = document.getElementById('symbolToRemoveAround').value;
                    const direction = document.getElementById('removeDirection').value;
                    if (symbol) {
                        result = uniqueLines.map(line => {
                            const index = line.indexOf(symbol);
                            if (index !== -1) {
                                return direction === 'before' ? line.slice(index) : line.slice(0, index + 1);
                            }
                            return line;
                        }).join('\n');
                    } else {
                        result = uniqueLines.join('\n');
                    }
                    break;
                default:
                    result = uniqueLines.join('\n');
            }

            const resultElement = document.getElementById('result');
            if (resultElement) {
                resultElement.value = result;
            }
        }

        // Добавьте эту функцию для обновления порядка кнопок в localStorage
        function saveButtonOrder() {
            const order = Array.from(document.querySelectorAll('.mode-button-container'))
                .map(container => container.dataset.modeId);
            localStorage.setItem('buttonOrder', JSON.stringify(order));
        }

        function addDragListeners() {
            const containers = document.querySelectorAll('.mode-button-container');
            const modeButtons = document.getElementById('mode-buttons');

            containers.forEach(container => {
                container.addEventListener('dragstart', (e) => {
                    draggedItem = container;
                    setTimeout(() => container.classList.add('dragging'), 0);
                });

                container.addEventListener('dragend', () => {
                    container.classList.remove('dragging');
                    saveButtonOrder();
                });
            });

            modeButtons.addEventListener('dragover', (e) => {
                e.preventDefault();
                const afterElement = getDragAfterElement(modeButtons, e.clientY);
                if (draggedItem && afterElement) {
                    modeButtons.insertBefore(draggedItem, afterElement);
                }
            });

            modeButtons.addEventListener('dragenter', (e) => e.preventDefault());
            modeButtons.addEventListener('drop', (e) => e.preventDefault());
        }

        function addTouchDragListeners() {
            const containers = document.querySelectorAll('.mode-button-container');
            const modeButtons = document.getElementById('mode-buttons');

            containers.forEach(container => {
                container.addEventListener('touchstart', handleTouchStart, false);
                container.addEventListener('touchmove', handleTouchMove, false);
                container.addEventListener('touchend', handleTouchEnd, false);
            });

            let draggedItem = null;
            let startY;

            function handleTouchStart(e) {
                draggedItem = this;
                startY = e.touches[0].clientY - draggedItem.offsetTop;
                setTimeout(() => draggedItem.classList.add('dragging'), 0);
            }

            function handleTouchMove(e) {
                if (!draggedItem) return;
                e.preventDefault();
                const currentY = e.touches[0].clientY - modeButtons.offsetTop;
                draggedItem.style.top = `${currentY - startY}px`;

                const afterElement = getDragAfterElement(modeButtons, currentY);
                if (afterElement) {
                    modeButtons.insertBefore(draggedItem, afterElement);
                } else {
                    modeButtons.appendChild(draggedItem);
                }
            }

            function handleTouchEnd() {
                if (!draggedItem) return;
                draggedItem.classList.remove('dragging');
                draggedItem.style.top = '';
                draggedItem = null;
                saveButtonOrder();
            }
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.mode-button-container:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function copyResult() {
            const resultElement = document.getElementById('result');
            resultElement.select();
            document.execCommand('copy');
            showNotification();
        }

        function showNotification() {
            const notification = document.getElementById('notification');
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.opacity = '1';
            }, 10);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 300);
            }, 2000);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const content = document.getElementById('content');
            sidebar.classList.toggle('open');
            document.body.classList.toggle('sidebar-open');
            
            if (sidebar.classList.contains('open')) {
                content.style.marginLeft = '80%';
            } else {
                content.style.marginLeft = '0';
            }
        }

        function handleResize() {
            if (window.innerWidth <= 768) {
                document.querySelectorAll('.drag-handle').forEach(handle => {
                    handle.style.display = 'none';
                });
            } else {
                document.querySelectorAll('.drag-handle').forEach(handle => {
                    handle.style.display = 'block';
                });
            }
        }

        const style = document.createElement('style');
        style.textContent = `
            body.sidebar-open {
                overflow: hidden;
            }
        `;
        document.head.appendChild(style);

        // Инициализация кнопок и первого режима
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded');
            createModeButtons();

            const processButton = document.getElementById('process-button');
            if (processButton) {
                processButton.addEventListener('click', processText);
            }

            const copyButton = document.getElementById('copy-button');
            if (copyButton) {
                copyButton.addEventListener('click', copyResult);
            }

            const burgerMenu = document.getElementById('burger-menu');
            const closeButton = document.getElementById('close-button');
            
            burgerMenu.addEventListener('click', toggleSidebar);
            closeButton.addEventListener('click', toggleSidebar);

            window.addEventListener('resize', handleResize);
        });
    </script>
</body>
</html>
